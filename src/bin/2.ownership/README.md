### exercise1

/\*
問題 1：文字列

2 つの文字列を結合し、新しい文字列を作成する関数を作成してください。
関数名: concatenate_strings
\*/

### exercise2

問題 2：構造体と所有権の複雑な関係

Book 構造体と Library 構造体を作成します。
Book 構造体には、title と author というフィールドがあり、それぞれ String 型です。
Library 構造体には、books というフィールドがあり、これは Vec<Book>型です。
Library 構造体に対して、add_book メソッドを作成し、新しい Book 構造体を books ベクターに追加できるようにします。

add_book メソッドは、Book 構造体の所有権を受け取り、Library 構造体の books ベクターに追加します。
main 関数内で、複数の Book 構造体を作成し、Library 構造体に追加する処理を実装します。
解答のヒント:
Vec は、要素の所有権を取得します。
add_book メソッドは、Book 構造体の所有権を移動させる必要があります。

### exercise3

問題 3：複数の所有権を持つ構造体
Book という構造体を定義します。この構造体は、title (文字列) と author (文字列) を持つものとします。
create_book という関数を作成し、title と author を引数として受け取り、Book 構造体のインスタンスを返します。
print_book_info という関数を作成し、Book 構造体の参照を受け取り、その情報をコンソールに出力します。
main 関数内で、create_book を 2 回呼び出し、それぞれの結果を別の変数に格納します。
2 つの Book 構造体の情報を print_book_info 関数を使って出力します。

### exercise4

問題 4: 可変参照と借用

double_first という関数を作成し、Vec<i32> の可変参照を受け取り、最初の要素を 2 倍にしたものを返します。

### exercise5

問題 5：参照とライフタイムの応用

print_longest という関数を作成します。
この関数は、2 つの文字列の参照を受け取り、より長い方の文字列を出力します。

関数の引数に渡される文字列のライフタイムを考慮し、コンパイルエラーが出ないようにします。
引数で渡された文字列のいずれかが変更された場合、関数の動作に影響が出ないようにします。
解答のヒント:
関数の引数にライフタイムパラメータを指定する必要があります。
スライスを使用して、文字列の長さを比較します。
